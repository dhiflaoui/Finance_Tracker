import{u as O}from"./CkJbm7BT.js";import{ad as T,ae as y,r as D,s as B,af as I,ag as E,x as M,j as S,v as b,ah as x,u as H,I as R,ai as V,q as f}from"./CVTLfr-j.js";const j=r=>r==="defer"||r===!1;function z(...r){var p;const o=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(o);let[s,u,e={}]=r;if(typeof s!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof u!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=T(),v=u,g=()=>y.value,w=()=>t.isHydrating?t.payload.data[s]:t.static.data[s];e.server=e.server??!0,e.default=e.default??g,e.getCachedData=e.getCachedData??w,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??y.deep,e.dedupe=e.dedupe??"cancel";const d=e.getCachedData(s,t),m=d!=null;if(!t._asyncData[s]||!e.immediate){(p=t.payload._errors)[s]??(p[s]=y.errorValue);const a=e.deep?D:B;t._asyncData[s]={data:a(m?d:e.default()),pending:D(!m),error:I(t.payload._errors,s),status:D("idle"),_default:e.default}}const n={...t._asyncData[s]};delete n._default,n.refresh=n.execute=(a={})=>{if(t._asyncDataPromises[s]){if(j(a.dedupe??e.dedupe))return t._asyncDataPromises[s];t._asyncDataPromises[s].cancelled=!0}if(a._initial||t.isHydrating&&a._initial!==!1){const l=a._initial?d:e.getCachedData(s,t);if(l!=null)return Promise.resolve(l)}n.pending.value=!0,n.status.value="pending";const c=new Promise((l,i)=>{try{l(v(t))}catch(C){i(C)}}).then(async l=>{if(c.cancelled)return t._asyncDataPromises[s];let i=l;e.transform&&(i=await e.transform(l)),e.pick&&(i=F(i,e.pick)),t.payload.data[s]=i,n.data.value=i,n.error.value=y.errorValue,n.status.value="success"}).catch(l=>{if(c.cancelled)return t._asyncDataPromises[s];n.error.value=x(l),n.data.value=H(e.default()),n.status.value="error"}).finally(()=>{c.cancelled||(n.pending.value=!1,delete t._asyncDataPromises[s])});return t._asyncDataPromises[s]=c,t._asyncDataPromises[s]},n.clear=()=>q(t,s);const h=()=>n.refresh({_initial:!0}),P=e.server!==!1&&t.payload.serverRendered;{const a=R();if(a&&!a._nuxtOnBeforeMountCbs){a._nuxtOnBeforeMountCbs=[];const i=a._nuxtOnBeforeMountCbs;E(()=>{i.forEach(C=>{C()}),i.splice(0,i.length)}),M(()=>i.splice(0,i.length))}P&&t.isHydrating&&(n.error.value||d!=null)?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):a&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?a._nuxtOnBeforeMountCbs.push(h):e.immediate&&h();const c=V();if(e.watch){const i=S(e.watch,()=>n.refresh());c&&b(i)}const l=t.hook("app:data:refresh",async i=>{(!i||i.includes(s))&&await n.refresh()});c&&b(l)}const _=Promise.resolve(t._asyncDataPromises[s]).then(()=>n);return Object.assign(_,n),_}function q(r,o){o in r.payload.data&&(r.payload.data[o]=void 0),o in r.payload._errors&&(r.payload._errors[o]=y.errorValue),r._asyncData[o]&&(r._asyncData[o].data.value=void 0,r._asyncData[o].error.value=y.errorValue,r._asyncData[o].pending.value=!1,r._asyncData[o].status.value="idle"),o in r._asyncDataPromises&&(r._asyncDataPromises[o]&&(r._asyncDataPromises[o].cancelled=!0),r._asyncDataPromises[o]=void 0)}function F(r,o){const s={};for(const u of o)s[u]=r[u];return s}const $=(r,o)=>{const s=O(),u=D([]),e=D(!1),t=f(()=>u.value.filter(a=>a.type==="Income")),v=f(()=>u.value.filter(a=>a.type==="Expense")),g=f(()=>t.value.length),w=f(()=>v.value.length),d=f(()=>t.value.reduce((a,c)=>a+c.amount,0)),m=f(()=>v.value.reduce((a,c)=>a+c.amount,0)),n=async()=>{e.value=!0;try{const{data:a}=await z(`transactions-${r.value.from.toDateString()}-${r.value.to.toDateString()}`,async()=>{const{data:c,error:l}=await s.from("transactions").select().gte("created_at",r.value.from.toISOString()).lte("created_at",r.value.to.toISOString()).eq("user_id",o).order("created_at",{ascending:!1});return l?[]:c});return a.value}catch(a){console.log("error while fetching transactions: ",a)}finally{e.value=!1}},h=async()=>u.value=await n();S(r,async()=>await h());const P=f(()=>{let a={};for(let c of u.value){const l=c.created_at.split("T")[0];a[l]||(a[l]=[]),a[l].push(c)}return a}),_=f(()=>d.value-m.value),p=f(()=>u.value.filter(a=>a.type==="Investment").reduce((a,c)=>a+c.amount,0));return{transactions:{all:u,grouped:{byDate:P},income:t,expense:v,incomeTotal:d,expenseTotal:m,incomeCount:g,expenseCount:w},savingsTotal:_,investmentsTotal:p,pending:e,refresh:h}};export{$ as u};
